export import "std/pointer.znn";
export import "std/builtin_types.znn";
export import "std/concepts.znn";
export import "std/builtin_types.znn";

export template <T>
int size(T[]* s) {
  embed_returns {
    return s->end - s->begin;
  }
}

export template <T>
bool empty(T[]* s) {
  return s->size() == 0;
}

export template <T>
T[] implicit_copy(T[]* s) {
  embed_returns {
    return *s;
  }
}

export template <T>
T* operator[](T[]* s, int index) {
  embed_returns {
    return &s->begin[index];
  }
}

export template <T>
struct slice_iterator {
  T* elem;
  int index;
};

export template <T>
slice_iterator<T> implicit_copy(slice_iterator<T>*) = default;

export template <T>
slice_iterator<T> begin(T[]* v) {
  embed_returns {
    return {v->begin, 0};
  }
}

export template <T>
slice_iterator<T> end(T[]* v) {
  const size = v->size();
  embed_returns {
    return {v->end, size};
  }
}

export template <T>
T* operator *(slice_iterator<T>* it) {
  return it->elem;
}

export template <T>
slice_iterator<T> operator ++(slice_iterator<T> mutable* it) {
  embed {
    ++it->elem;
  }
  ++it->index;
  return implicit_copy(it);
}

export template <T>
bool operator == (slice_iterator<T>* it1, slice_iterator<T>* it2) {
  embed_returns {
    return it1->elem == it2->elem;
  }
}

export template <T>
bool operator != (slice_iterator<T>* it1, slice_iterator<T>* it2) {
  embed_returns {
    return it1->elem != it2->elem;
  }
}

export template <T> requires can_hash<T>
int get_hash(T[] v) {
  mutable res = 0;
  mutable u = 1;
  for (elem : v) {
    res += u * elem->get_hash();
    u *= 5;
  }
  return res;
}

export template <T> requires comparable<T>
bool operator == (T[] v1, T[] v2) {
  if (v1.size() != v2.size())
    return false;
  for (i = 0; i < v1.size(); ++i)
    if (!(v1[i] == v2[i]))
      return false;
  return true;
}

export template <T, int N>
T[] slice(T[N]* array) {
  embed_returns {
    if (array->empty())
      return slice_t<T>{nullptr, nullptr};
    return slice_t<T>{&array->front(), &array->back() + 1};
  }
}
