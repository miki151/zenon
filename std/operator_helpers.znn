
export import "std/concepts.znn";

export concept <T, U> equality_impl {
  bool operator == (T*, U*);
};

export template <T, U> requires equality_impl<T, U>
bool operator != (T* t, U* u) {
  return !(*t == *u);
}

export concept <T, U> increment_by_impl {
  T operator + (T*, U*);
};

export template <T, U> requires increment_by_impl<T, U>
void operator +=(T mutable* t, U* u) {
  *t = *t + *u;
}

export concept <T, U> decrement_by_impl {
  T operator - (T*, U*);
};

export template <T, U> requires decrement_by_impl<T, U>
void operator -=(T mutable* t, U* u) {
  *t = *t - *u;
}

export concept <T, U> multiply_by_impl {
  T operator * (T*, U*);
};

export template <T, U> requires multiply_by_impl<T, U>
void operator *=(T mutable* t, U* u) {
  *t = *t * *u;
}

export concept <T, U> divide_by_impl {
  T operator / (T*, U*);
};

export template <T, U> requires divide_by_impl<T, U>
void operator /=(T mutable* t, U* u) {
  *t = *t / *u;
}

