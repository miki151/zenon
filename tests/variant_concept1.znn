// 5

struct A {
};

int getValue(A& a) {
  return 2;
}

struct B {
  int a;
};

int getValue(B& b) {
  return (*b).a;
}

template <S>
concept hasValue {
  int getValue(S& s);
};

template <S> requires hasValue<S>
variant V {
  S s;
  void null;
};

template <S> requires hasValue<S>
int getValue(V<S>& v) {
  switch (*v) {
    case (S s) {
      return s.getValue();
    }
    case (null) {
      return -1;
    }
  }
}


int main() {
  const v1 = V<A>::s(A());
  const v2 = V<B>::s(B(4));
  const v3 = V<A>::null();
  return v1.getValue() + v2.getValue() + v3.getValue();
}
